\chapter{The CHERI-x86-64 Instruction-Set Architecture (Sketch)}
\label{chap:cheri-x86-64}

\rwnote{New introduction is required, and some change of pitch.}

In this chapter, we explore models for applying CHERI protection to the x86
architecture.
The x86 architecture is a widely deployed CPU architecture used in a
variety of applications ranging from mobile to high-performance computing.
The architecture has evolved over time from 16-bit processors without
MMUs to present-day systems with 64-bit processors supporting virtual
memory via a combination of segmentation and paging.

The x86 architecture has spanned three register sizes (16, 32, and
64 bits) and multiple memory management models.  We choose to define
CHERI solely for the 64-bit x86 architecture for a variety of reasons
including its more mature virtual-memory model, as well as its larger
general-purpose integer register file.

\section{Capability Registers versus Segments}

The x86 architecture first added virtual memory support via
relocatable and variable-sized segments.  Each segment was assigned a
mask of permissions.  Memory references were resolved with respect to a
specific segment including relocation to a base address, bounds
checking, and access checks.  Special segment types permitted transitions
to and from different protection domains.

These features are similar to features in CHERI capabilities.
However, there are also some key differences.

First, x86 addresses are stored as a combination of an offset and a
segment spanning two different registers.  General-purpose registers
are used to hold offsets, and dedicated segment selector registers are
used to hold information about a single segment.  The x86 architecture
provides six segment selector registers -- three of which are reserved
for code, stack, and general data accesses.  A fourth register is
typically used to define the location of thread-local storage (TLS).
This leaves two segment registers to use for fine-grained segments
such as separate segments for individual stack variables.  These
registers do not load a segment descriptor from arbitrary locations in
memory.  Instead, each register selects a segment descriptor from a
descriptor table with a limited number of entries.  One could treat
the segment descriptor tables (or portions of these tables) as a cache
of active segments.

Second, more fine-grained segments are not derived from existing
segments.  Instead, each entry in a descriptor table is independent.
Write access to a descriptor table permits construction of arbitrary
segments (including special segments that permit privilege
transitions).  Restricting descriptor-table write access to kernel
mode does not protect against construction of arbitrary segments in
kernel mode due to bugs or vulnerabilities.  As a result, segment
descriptors are not able to provide the same provenance guarantees as
tagged capabilities.

Third, existing segment descriptors do not have available bits for
storing types or permissions more expressive than the existing
read, write, and execute.

Finally, x86 segmentation is typically not used in modern operating
systems.  On the 32-bit x86 architecture, systems generally create
segments with infinite bounds and use a non-zero base address only
for a single segment that provides TLS.  The 64-bit x86 architecture
codifies this by removing segment bounds entirely and supporting non-zero-base
addresses only for two segment registers.
Software for x86 systems stores only the offset portion of virtual
addresses in pointer variables.  Segment registers are set to fixed
values at program startup, never change, and are largely ignored.

One approach for providing a similar set of features to CHERI
capabilities on x86 would be to extend the existing segment primitives
to accommodate some of these differences.  For example, descriptor-table
entries could be tagged, whereby loading an untagged segment would trigger
an exception.  However, some other potential changes are broader in
scope (e.g., whether segment selectors should contain an index into a
table, versus a logical address of a segment descriptor).  Extending
segments would also result in a very different model compared to CHERI
capabilities on other architectures, limiting the ability to share code
and algorithms.  Instead, we propose to add CHERI capabilities to 64-bit
x86 by extending existing general-purpose integer registers.

\section{Tagged Capabilities and Memory}

As with CHERI-MIPS and CHERI-RISC-V, we recommend that both memory and
registers contain tagged capabilities.  Similar to CHERI-RISC-V, we also
recommend a single, 128-bit format for CHERI-x86-64 capabilities.

Since capabilities require 16 byte alignment in memory, attempts to
load or store capabilities at misaligned addresses should raise a
General Protection Fault with an error code of zero similar to
misaligned loads and stores of SSE registers.

\section{Extending Existing Registers}

The x86 architecture has expanded its general-purpose integer registers multiple
times.  Thus, the 16-bit \AX{} register has been extended to 32-bit \EAX{}
and 64-bit \RAX{}.
We propose extending each general-purpose integer register to a tagged, 128-bit register
able to contain a single capability.
The capability-sized registers would be named with a `C' prefix in place
of the `R' prefix used for 64-bit registers
(\CAX{}, \CBX{}, etc.).
As with CHERI-RISC-V,
we recommend that the bottom 64 bits of capability registers contain
the integer value (virtual address) and the upper 64 bits contain
capability metadata.
Reads of capability registers as integers return the integer value.
Integer writes to capability registers
should clear the tag and upper 64 bits of capability metadata, storing the
desired integer value in the bottom 64 bits.

The \RIP{} register (which contains the address of the current instruction)
would also be extended into a \CIP{} capability.  This would function as
the equivalent of \PCC{} for CHERI-MIPS and CHERI-RISC-V.  As with
those architectures, the
value of \RIP{} should be the current offset of \CIP{} rather than the
integer value (virtual address).

\section{Additional Capability Registers}

Additional capability registers beyond those present in the general-purpose
integer
register set will also be required.

A new register will be required to hold \DDC{} for controlling
non-capability-aware memory accesses.

The x86 architecture currently uses the \FS{} and \GS{} segment selector registers
to provide thread-local storage (TLS).  In the 64-bit x86 architecture,
these selectors are mostly reduced to holding an alternate base address
that is added as an offset to the virtual address of existing instructions.
For CHERI-x86-64 we recommend replacing these segment registers with two
new capability registers: \CFS{} and \CGS{}.

In addition, new capability registers may be required to manage user
to kernel transitions as detailed below.

\section{Using Capabilities with Memory Address Operands}

As with other CHERI architectures, CHERI-x86-64 should support running existing
x86-64 code, capability-aware code, and hybrid code.  This
requires the architecture to support multiple addressing modes.
The x86 architecture has implemented this in the past when it was
extended to support 32-bit operation.  We propose to reuse some of the
same infrastructure to support a new capability-based addressing
mode.

When x86 was extended from 16 bits to 32 bits, the architecture
included the ability to run existing 16-bit code without modification
as well as execute individual 16-bit or 32-bit instructions within a
32-bit or 16-bit codebase.  The support for 16-bit versus 32-bit
operation was
split into two categories: operand size and addressing modes.  The
code segment descriptor contains a single-bit `D' flag, which sets the
default operand size and addressing mode.  These attributes can then
be toggled to the non-default setting via opcode prefixes.  The 0x66
prefix is used to toggle the operand size, and the 0x67 prefix is used
to toggle the addressing mode.

In 64-bit (``long'') mode, the `D' flag is currently always set to
0 to indicate 32-bit operands and 64-bit addressing.  A value of
1 for `D' is reserved.  The 0x67 opcode prefix is used to toggle
between 32-bit and 64-bit addresses, but a few other single-byte opcodes
are invalid in 64-bit mode and could be repurposed as a prefix.

We propose a new capability-aware addressing mode that can be
toggled via the `D' flag of the current code segment and a new 0x62
opcode prefix.  (In 32-bit x86, the 0x62 opcode is the
\insnnoref{BOUND} instruction, which is invalid in 64-bit mode.)
If the `D' flag of a 64-bit code segment is set to 1,
then the CPU would execute in ``capability mode'' -- which would include
using the capability-aware addressing mode by default.  Individual
instructions could toggle between capability-aware and ``plain''
64-bit addressing via the 0x62 opcode prefix.  Addresses using the
``plain'' 32-bit or 64-bit addressing would always be treated as offsets
relative to \DDC{}.  Instructions using capability-aware addressing
would always use 64-bit virtual addresses and ignore any 0x67 opcode
prefix.

Note that one can change the value of \CS{} in user mode (for example,
a user process in FreeBSD/amd64 can switch between 32 and 64-bit by
using a far call that loads a different value of \CS{}).  This would mean
that user code could swap into pure-capability mode without requiring
a system call.  However, this would not alter the contents of
capability registers or their enforcement, merely the decoding of
instructions.  If \DDC{} is invalid, then sandboxed code that switched to
a non-capability \CS{} would still require valid capability registers to
access memory.

\subsection{Capability-Aware Addressing}

For instructions with register-based memory operands, capability-aware
addressing would use the capability version of the register rather
than the virtual address relative to \DDC{}.

For example:

\begin{verbatim}
mov 0x8(%cbp),%rax
\end{verbatim}

would read the 64-bit value at offset 8 from the capability described
by the \CBP{} register.

On the other hand,

\begin{verbatim}
mov 0x8(%rbp),%rax
\end{verbatim}

would read the 64-bit value at an offset of RBP+8 from the \DDC{} capability.
Both instructions would use the same opcode aside from the addition of
an 0x62 opcode prefix.  In a code segment with `D' set to 1, the second
instruction would require the prefix.  In a code segment with `D' set to 0,
the first instruction would require the prefix.

\subsection{Scaled-Index Base Addressing}

x86 also supports an addressing mode that combines the values of two
registers to construct a virtual address known as scaled-index base
addressing.  These addresses use one register, the \emph{base}, and a
second register, the \emph{index}, multiplied by a scaling factor of 1, 2,
4, or 8.  For these addresses, capability-aware addresses would select
a capability for the base register, but the index register would use
the integer value of the register.  For example:

\begin{verbatim}
mov (%rax,%rbx,4),%rcx
\end{verbatim}

This computes an effective address of \RAX{} + \RBX{} * 4 and loads the value
at that address into \RCX{},  The capability-aware version would be:

\begin{verbatim}
mov (%cax,%rbx,4),%rcx
\end{verbatim}

That is, starting with the \CAX{} capability, \RBX{} * 4 would be added to the
offset, and the resulting address validated against the \CAX{} capability.

\subsection{RIP-Relative Addressing}

The 64-bit x86 architecture added a new addressing mode to support more
efficient Position-Independent Code (PIC) performance.
This addressing mode uses an immediate offset
relative to the current value of the instruction
pointer.  These addresses are known as \RIP{}-relative addresses.

To support existing code, \RIP{}-relative addresses should be resolved
relative to \DDC{} when using ``plain'' 64-bit addressing.
Specifically, the value of \RIP{} (offset of \CIP{}) would be added to
the immediate offset.  The resulting value would then be used as an
offset relative to \DDC{} for the load or store.

When capability-aware addressing is used, \RIP{}-relative addresses
should be resolved relative to \CIP{}.
The immediate offset is applied to \CIP{} and the load
or store is constrained by the bounds and permissions of \CIP{}.

\subsection{Using Additional Capability Registers}

The proposed capability-aware addressing mode proposed above allows
for the capability versions of existing general-purpose integer registers such
as \CAX{} or \CBP{} to be encoded in existing register instructions.
However, it does not permit the direct use of the additional
capability registers \DDC{}, \CFS{}, or \CGS{}.  \DDC{} is not expected to be
used as an explicit base address, but \CFS{} and \CGS{} must be usable in this
manner to support TLS with capability-aware addresses.

One option would be to repurpose the existing \FS{} and \GS{} segment
prefixes when used with instructions using capability-aware addresses
to select an implicit base register of \CFS{} or \CGS{}, respectively.
However, this approach is potentially confusing.  Would an instruction
using an existing address of ``(\%cax)'' and an instruction prefix of
``GS:'' simply use the integer value of \CAX{} (value of \RAX{}) as an offset
relative to \CGS{}?  In addition, instructions that manipulate
capabilities need a way to specify an additional capability register
as an operand.

To handle both of these cases, we propose to reuse the existing \FS{} and
\GS{} segment prefixes to extend the capability register selector field
in opcodes.  This is similar to the use of bits in \REX{} prefixes to
extend the general-purpose integer register selector fields in other
instructions.  Instructions with memory addresses will use at most one
capability-register, and the \FS{} prefix could be used to select
capability registers with an index of 32 or higher.  For instructions
operating on two capability registers, the \FS{} prefix would affect the
register selected for the first capability register operand, and the
\GS{} prefix would affect the register selected for the second capability
register operand.  Additional capability registers such as \DDC{}, \CFS{},
and \CGS{} would be assigned register indices starting at 32 and require
a suitable prefix.

\subsection{Instructions with Implicit Memory Operands}

Some x86 instructions have implicit memory operands addressed by a
register.  These instructions should support addressing memory with
capabilities.

The ``string''
instructions use \RSI{} as source address and \RDI{} as a destination address.
For example, the
\insnnoref{STOS} instruction stores the value in \AL{}/\AX{}/\EAX{}/\RAX{} to the address in
\RDI{}, and then either increments or decrements the destination
index register (depending on the Direction Flag).  When capability
addressing mode is enabled,
these string instructions should use \CSI{} instead of \RSI{} and \CDI{} instead of
\RDI{}.

\insnnoref{XLAT} should use \CBX{} as the implicit table address when
using capability-aware addressing.

\subsection{Stack Address Size}

Instructions that work with the stack such as \insnnoref{PUSH} or
\insnnoref{CALL} use the stack pointer as an implicit operand.  In
32-bit x86, the `B' flag of the stack segment selector determines if
the 16-bit or 32-bit stack pointer register is used.  In 64-bit long
mode, \RSP{} is always used as the stack pointer.

To support a CHERI stack pointer, we propose reusing the `B' flag of
the stack segment selector to determine the stack pointer.  When `B'
is clear, \RSP{} would be treated as an offset into \DDC{} to compute
the stack pointer.  When `B' is set, \CSP{} would be used as the stack
pointer.  Code which needs to use the alternate stack pointer
interpretation would simulate these instructions using \insnnoref{MOV}
instructions and adjusting the desired stack pointer using
instructions such as \insnnoref{ADD} or \insnnoref{SUB}.  Emulation of
\insnnoref{CALL} or \insnnoref{RET} would use \insnnoref{JMP} to
adjust the instruction pointer.

\section{Capability-Aware Instructions}

CHERI-x86-64 will require new instructions to examine and modify
capabilities.  Many of these new instructions can be implemented as
new variants of existing instructions that use an opcode which
specifies a capability operation rather than an integer operation.
Existing x86 toolchains already use instruction suffixes such as
\texttt{b}, \texttt{w}, \texttt{l}, and \texttt{q} to explicitly state
the operand size.  We recommand that the \texttt{c} suffix be used to
explicitly state operands which are capability-sized.

Previous extensions to the x86 architecture have relied on opcode
prefixes combined with the `D' and `L' flags of the current code
segment to determine the operand size.  We propose a similar
scheme for supporting capability-sized operands.

First, we propose reusing a single-byte opcode declared invalid in
64-bit mode such as 0x07 (\insnnoref{POP ES}) as an opcode prefix
(\textbf{capability operand prefix}).

When not executing in ``capability mode'', existing instructions will
follow the existing rules for 64-bit ``long mode'' as defined by the
0x66 prefix and \texttt{REX.W} flag to set the operand size.  If an
instruction supports capability-sized operands, the capability operand
prefix can be used to use a capability-sized operand instead.  This
prefix would have higher precedence than both both \texttt{REX.W} and
the 0x66 prefix.

In ``capability mode'', most instructions which can operate on either
integer or capability-sized values will follow the same logic in the
previous paragraph to determine the operand size.  However, a few
instructions will default to using a capability-sized operand when
executed in ``capability mode''.  For these instructions, the
capability operand prefix can be used to revert to a smaller operand
size.  The effective operand size is then determined by \texttt{REX.W}
and the 0x66 prefix.  The following sections will describe the default
operand size in ``capability mode'' for instructions which support
both integer and capability operands.

Finally, some instructions may only operate on capabilities.  For
these instructions, prefixes are ignored and the operand is always
capability-sized.

\subsection{Control-Flow Instructions}

Relative control-flow instructions such as \insnnoref{JMP},
\insnnoref{CALL}, and conditional jumps (\insnnoref{Jcc}) would modify
the offset of the \CIP{} capability.  If the resulting value of \CIP{}
is invalid, a capability violation fault would be raised when fetching
the next instruction (see Section~\ref{sec:x86:capability-fault}).

Absolute near calls and jumps would support both integer and
capabality-sized operands.  Instructions using an integer operand
would set the address of the \CIP{} capability while instructions
using a capability operand would load a new capability into \CIP{}.
Research is required to determine the default operand size of absolute
near calls and jumps in ``capability mode''.  For now, we recommend
that the default be capability-sized.

Far calls and jumps would support both integer and capability-sized
operands.  For capabity-sized operands, the memory address points to
to a 16-bit segment selector followed by a capability.  Note that the
capability must be suitably aligned.  The current segment selector is
pushed on the stack as a 16-byte value where the first two bytes
contain the selector and the remaning 14 bytes' value is undefined.

A \insnnoref{RETC} should pop a capability off of the stack which is
loaded into \CIP{}.  A far \insnnoref{RETC} should additionally pop
off a 16-byte value off of the stack of which the low 16 bits are used
as the new code segment selector.  The \insnnoref{RET} instruction
should default to a capability operand in ``capability mode''.

\insnnoref{IRETC} should pop a capability execption frame (see
Section~\ref{sec:x86:interrupt-exception}) from the stack loading
capabilities into \CIP{} and \CSP{}.  The \insnnoref{IRET} instruction
should default to a capability operand in ``capability mode''.

Note that attempting to push or pop a misaligned capability will raise
an exception.  The stack pointer must be suitably aligned before the
use of \insnnoref{CALLC}, \insnnoref{IRETC}, and \insnnoref{RETC}.

\subsection{Extending Existing Instructions to Support Capability Operands}

Several existing instructions should be extended to support
capability operands:

\begin{itemize}
  \item \insnnoref{MOVC} would handle loads and stores of
    capabilities similar to \insnref{CLC} and \insnref{CSC} as well as
    copying capabilities between registers similar to \insnref{CMove}.

    When the capability operand prefix is used with the \texttt{C7 /0}
    variant of \insnnoref{MOV} which accepts a 32-bit immediate
    operand, this instruction should store a NULL-derived capability
    using the immediate operand sign-extended to 64 bits as the
    integer value of the resulting capability.

    To provide a more compact form for storing NULL pointers into
    memory, it may also be desirable to support the capability operand
    prefix with the \texttt{C6 /0} opcode which accepts an 8-bit
    immediate.

    \insnnoref{MOV} should default to integer operands in ``capability
    mode''.

  \item \insnnoref{CMOVC} would handle conditional loads and stores of
    capabilities.

    \insnnoref{CMOV} should default to integer operands in
    ``capability mode''.

  \item \insnnoref{ADDC} and \insnnoref{SUBC} would be used to adjust
    the offset of a capability similar to \insnref{CIncOffset}.  Note
    that for these instructions, the source operand would either be a
    sign-extended immediate or a 64-bit integer register whose value
    is either added to or subtracted from the capability-sized
    destination operand.

    For example:
 
\begin{verbatim}
add %csp,$16
\end{verbatim}

    would move the capability stack pointer up by 16 bytes.

    These instructions should set flag bits in \RFLAGS{} according to
    the integer value of the resulting capability.

    \insnnoref{ADD} and \insnnoref{SUB} should default to integer
    operands in ``capability mode''.

    We do not anticipiate a need for capability-sized variants of
    \insnnoref{ADC} or \insnnoref{SBB}.

  \item \insnnoref{ANDC}, \insnnoref{ORC}, and \insnnoref{XORC} would
    permit bit manipulation of the integer value of a capability.  As
    with \insnnoref{ADDC}, the second operand would always be an
    integer operand.

    These instructions should set flag bits in \RFLAGS{} according to
    the integer value of the resulting capability.

    \insnnoref{AND}, \insnnoref{ORC}, and \insnnoref{XOR} should
    default to integer operands in ``capability mode''.

  \item \insnnoref{CMPC} would perform a complete comparison of two
    capabilities similar to \insnref{CSetEqualExact} setting
    \texttt{ZF} to the result of the comparison.  Other flags would
    not be affected by this instruction.  This is somewhat different
    than other variants of \insnnoref{CMP} which perform the
    equivalent \insnnoref{SUB} instruction and then discard the
    result as in this case the flags set would not be identical to the
    flags set as a result of \insnnoref{SUBC}.

    We do not anticipate a need for a capability-sized variant of
    \insnnoref{TEST}.

    \insnnoref{CMP} should default to integer operands in ``capability
    mode''.

  \item \insnnoref{CMPXCHGC} will be required to support atomic
    operations on capabilities.  (Note that \insnnoref{CMPXCHG16B}'s
    existing semantics are not suitable for capabilities as it divides
    the values into register pairs.)

    \insnnoref{CMPXCHG} should default to integer operands in
    ``capability mode''.

  \item It may also be desirable to support \insnnoref{XADDC}.  For
    this instruction, only the integer portion of the second (source)
    operand would be added to the integer value of the first
    (destination) operand to determine the value stored to the
    destination.  Any tag or capability metadata in the second operand
    would be ignored and would be overwritten with the original value
    of the first operand.

    \insnnoref{XADDC} should set flag bits in \RFLAGS{} according to
    the integer value of the resulting capability.

    \insnnoref{XADD} should default to integer operands in
    ``capability mode''.

  \item \insnnoref{PUSHC} and \insnnoref{POPC} would be used to save
    and restore capability registers on the stack.

    \insnnoref{PUSH} and \insnnoref{POP} should default to capability
    operands in ``capability mode''.

  \item \insnnoref{LEAC} would storing the resulting address in a
    destination register.  If the instruction is using ``plain''
    addressing, the resulting capability would be a NULL-derived
    capability with the computed address.

    \insnnoref{LEA} should default to capability operands in
    ``capability mode''.

    \insnnoref{LEA}'s default disposition in ``capability mode''
    warrants further investigation.  If common use cases of this
    instruction are to perform arithmetic operations on integer values
    rather than computing addresses, it may make sense for
    \insnnoref{LEA} to use integer operands and ``plain'' addressing
    by default even in ``capability mode''.

  \item \insnnoref{ENTER} and \insnnoref{LEAVE} could be extended to
    support implicit capability operands, or they could be deprecated
    for capabilities and remain as integer-only instructions.

    If these instructions were extended to support capability
    operands, the capability-sized versions would operate on \CSP{}
    and \CBP{} rather than \RSP{} and \RBP{}.  These instructions
    would also default to capability operands in ``capability mode''
    if extended.
\end{itemize}

\subsection{New CHERI Instructions}

For other capability operations we
propose adding new CHERI-specific instructions.
Existing general-purpose x86 instructions support two operands rather
than three operands.  To avoid introducing a new operand encoding
format, we propose to use two-operand variants of CHERI
instructions when adapting instructions to x86.

Three operand instructions could be introduced by using VEX prefixes.
However, the use of capabilities from the upper bank of capability
registers such as \DDC{}, \CFS{}, or \CGS{} as operands would require
extra care.  One option would be to reuse the \ES{} segment prefix to
extend the third operand field to five bits.

Operands are described using the syntax from Volume 2 of Intel's
Software Developer's Manual~\cite{intel-sdm-vol2} with the following
extensions:

\begin{itemize}
  \item \textbf{rc} { }---{ } One of the capability general-purpose
    registers: \CAX{}, \CBX{}, \CCX{}, \CDX{}, \CDI{}, \CSI{}, \CBP{},
    \CSP{}, \creg{8}-\creg{15}, \DDC{}, \CFS{}, \CGS{}; or one of
    capability control registers: \KCC{}, \KSC{}, \CSTAR{}, or \KGS{}.

  \item \textbf{r/mc} { }---{ } A capability operand that is either
    the contents of one of the capability registers for \textbf{rc} or
    a capability in memory.

   \item \textbf{uimm16} { }---{ } An unsigned immediate value.  This
     is a number between 0 and 65,535 inclusive.
\end{itemize}

\subsubsection{Capability-Inspection Instructions}

These instructions would set the \texttt{PF}, \texttt{SF}, and
\texttt{ZF} flags in \RFLAGS{} according to the integer field
extracted from the capability.

\begin{itemize}
  \item \insnref{CGetPerm} r64, r/mc
  \item \insnref{CGetType} r64, r/mc
  \item \insnref{CGetBase} r64, r/mc
  \item \insnref{CGetLen} r64, r/mc
  \item \insnref{CGetTag} r64, r/mc
  \item \insnref{CGetSealed} r64, r/mc
  \item \insnref{CGetOffset} r64, r/mc
  \item \insnref{CGetFlags} r64, r/mc
  \item \insnref{CGetSealed} r64, r/mc
  \item \insnref{CGetAddr} r64, r/mc
\end{itemize}

\subsubsection{Capability-Modification Instructions}

\begin{itemize}
  \item \insnref{CSeal} r/mc, rc
  \item \insnref{CUnSeal} r/mc, rc
  \item \insnref{CAndPerm} r/mc, r64
  \item \insnref{CSetFlags} r/mc, r64
  \item \insnref{CSetOffset} r/mc, r64
  \item \insnref{CSetAddr} r/mc, r64
  \item \insnref{CSetBounds} r/mc, r64
  \item \insnref{CSetBounds} r/mc, uimm16
  \item \insnref{CSetBoundsExact} r/mc, r64
  \item \insnref{CClearTag} r/mc
  \item \insnref{CBuildCap} r/mc, rc
  \item \insnref{CCopyType} r/mc, rc
  \item \insnref{CCSeal} r/mc, rc
  \item \insnref{CSealEntry} r/mc
\end{itemize}

\subsubsection{Pointer-Arithmetic Instructions}

\begin{itemize}
  \item \insnref{CToPtr} rc, r/mc
  \item \insnref{CFromPtr} r/mc, r64
\end{itemize}

\subsubsection{Pointer-Comparison Instructions}

For this instruction, the result of the comparison should be written
to the \texttt{ZF} field of \RFLAGS{} instead of to a destination
register as is done in CHERI-MIPS and CHERI-RISC-V.

\begin{itemize}
  \item \insnref{CTestSubset} r/mc, rc
\end{itemize}

Additionally, to support efficient tag checks without overwriting an
integer register with the result as is done in \insnref{CGetTag}, a
single operand \insnnoref{CTestTag} which copies the tag value to
\texttt{ZF} may be desired.

\subsubsection{Control-Flow Instructions}

\begin{itemize}
  \item \insnref{CInvoke} rc, r/mc
\end{itemize}

\subsubsection{Adjusting to Compresssed Capability Precision
  Instructions}

\begin{itemize}
  \item \insnref[CRoundRepresentableLength]{CRRL} r64, r/m64
  \item \insnref[CRepresentableAlignmentMask]{CRAM} r64, r/m64
\end{itemize}

\subsubsection{Tag-Memory Access Instructions}

These instructions always use capability addressing mode.

\begin{itemize}
  \item \insnref{CLoadTags} r64, m
  \item \insnref{CClearTags} m
\end{itemize}

\section{Capability Violation Faults}
\label{sec:x86:capability-fault}

For reporting capability violations, we propose reserving a new
exception vector.  This new exception would report an error code
pushed as part of the exception frame similar to GP\# and PF\# faults.
This error code would contain the capability exception code as
described in Section~\ref{sec:capability_exception_causes} to indicate
the specific violation.

CHERI-MIPS and CHERI-RISC-V include the name of the register which
triggers a capability violation.  It is not feasible to provide a
direct analog of this on x86.  Indirect jumps and calls may raise an
exception while loading a capability from memory that is not present
in any register at the start of the instruction.  However, unlike page
faults, capability violation faults are not generally restartable and
the register name's primary use is for debugging convenience rather than
correctness.  There are a few possible options for providing similar
information:

\begin{enumerate}
\item Provide a copy of the faulting capability via one of the
  currently-unused but reserved control registers, such as \CRFIVE{}
  or \CRTWELVE{} -- similar to the PF\# virtual address stored in
  \CRTWO{}.  This faulting capability would include the result of any
  offset adjustments from immediates or scaled indices.  If the result
  of offset adjustments made the capability unrepresentable, the
  faulting capability would be a null capability holding the computed
  virtual address.
\item Similar to the above, but ignore offset adjustments and only
  provide the base capability value.
\item Provide the virtual address from the faulting capability in
  \CRTWO{} similar to PF\#.  A debugger could examine the faulting
  instruction's operands to determine which capability triggered the fault.
\item Do nothing as the prior approaches may be too expensive to
  implement.
\end{enumerate}

\section{Interrupt and Exception Handling}
\label{sec:x86:interrupt-exception}

For interrupt and exception handling, we propose a new overall CPU
mode that enables the use of capabilities.  The availability of this
mode would be indicated by a new \insnnoref{CPUID} flag.  The mode
would be enabled by setting a new bit in \CRFOUR{}.  When this mode is
enabled, exceptions would push a new type of interrupt frame.  As with
exceptions in long mode, the stack pointer would be 16-byte aligned
prior to pushing the exception frame to ensure capabilities are
aligned.  The \RIP{} and \RSP{} fields in the exception frame would be
replaced with the full \CIP{} and \CSP{} capabilities.  Other fields
in this frame would be padded to 16 bytes.  To minimize padding, it
may be desirable to pack multiple smaller registers into a single
16-byte slot; for example, \SS{}, \CS{}, and \RFLAGS{} could be stored
in a single slot.  However, this would result in a frame layout
inconsistent with far calls.  \insnnoref{IRETC} would be used in
interrupt service routines to unwind this frame.

Interrupt and exception handlers require new capabilities for the
program counter (\CIP{}) and stack pointer (\CSP{}) registers.  We consider
two possible approaches.

\subsection{Kernel Code and Stack Capabilities}

The first approach would add two new control registers: the Kernel
Code Capability (\KCC{}) and Kernel Stack Capability (\KSC{}).  Access to
these registers would be restricted to supervisor mode.  These new registers
could be named as instruction operands, using the same approach decribed
earlier for \CFS{} and \CGS{}.

Transitions into
supervisor mode would load new offsets relative to \KCC{} and \KSC{} from
existing data structures and tables to construct the new \CIP{} and \CSP{}
register values.  For example, the current virtual address stored in
each Interrupt Descriptor Table (\IDT{}) entry would be used as an offset
relative to \KCC{} to build \CIP{}, and the address stored in the Interrupt
Stack Table (\IST{}) entry in the current Task-State Segment (\TSS{}) would
be used as an offset relative to \KSC{} to build \CSP{}.  Transitions via
the \insnnoref{SYSCALL} instruction would use the offset from \LSTAR{} to
construct the new \CIP{}.

This approach does require broad capabilities
for \KCC{} and \KSC{} that can accommodate any desired entry point or stack
location.  However, it will require minimal changes to existing systems
code such as operating-system kernels.

\subsection{Capabilities in Entry Points}

The second approach would be to replace virtual addresses stored in
existing entry points with complete capabilities.  This is a more
invasive change, requiring larger changes to existing systems code, but
it enables the use of more fine-grained capabilities for each entry
point.

Setting the desired kernel stack pointers \CSP{} would require a new
\TSS{} layout that expanded the existing \RSP{} and \IST{} entries to
capabilities.

For \insnnoref{SYSCALL}, a new control register \CSTAR{} could be
added to hold the target instruction pointer.  As with \KCC{},
this register would be a privileged register in the same bank as
\CFS{} and \CGS{}.

Entries in the \IDT{} would be expanded to 32-bytes, appending a capability
code pointer in the last 16 bytes.  This would double the size of the
\IDT{}, and most of the bytes would be unused.  However, it would
ensure that all of the information currently stored in an \IDT{} entry
(such as the segment selector, \IST{} index, and descriptor type) would
be configurable.

\subsection{\insnnoref{SWAPGS} and Capabilities}

The \insnnoref{SWAPGS} instruction is used in user-to-kernel
transitions for the 64-bit x86 architecture to permit separate TLS
pointers for user and kernel mode.  One option would be to provide a
capability version of \insnnoref{SWAPGS}, either by extending the
\KGSBASE{} MSR to a capability, or adding a new MSR.  However, this
instruction can be difficult to use.  Interrupt and exception handlers
must be careful not to invoke \insnnoref{SWAPGS} if the interrupt
or exception is taken while executing the kernel mode \GS{}.  We
recommend avoiding the use of \insnnoref{SWAPGS}, and instead defining
a new privileged control register \KGS{}.  Operating systems could
either choose to use \KGS{} to initialize \CGS{} in interrupt and
exception handlers, or else use \KGS{} directly as the kernel mode TLS
pointer.

\section{Page Tables}

Similar to CHERI on other architectures, additional page-table
permission bits governing loads and stores of capabilities are
desirable.  In addition, it may be beneficial to have a ``capability
dirty'' bit.  At present the 64-bit x86 architecture has reserved bits
in a range from bit 52 (\texttt{MAXPHYADDR}) to bit 62.  The Protection Keys
extension uses bits 59-62 from that range.  To avoid conflicting with
Protection Keys, CHERI-x86-64 could use bits starting at bit 58 as described in Table~\ref{table:x86:pte}.  Higher bits are
preferred, to permit maximal room for growth of the physical address
field that currently ends at bit 51.

\begin{table}
\begin{center}
\begin{tabular}{lll}
\toprule
Bit & Name & Description \\
\midrule
58 & CW & Permits writes of tagged capabilities \\
57 & CR & Permits reads of tagged capabilities \\
56 & CD & Set when a tagged capability is written to this page \\
\bottomrule
\end{tabular}
\end{center}
\caption{CHERI-x86-64 Page Table Bits}
\label{table:x86:pte}
\end{table}

If an instruction performs a memory access which violates a CHERI page
permission (such as a store of a tagged capability to a page where the
\texttt{CW} bit is clear), a page-fault (PF\#) exception should be
raised.  Bit 6 (currently reserved) should be set in the page-fault
error code provided by the processor indicating that the fault was
caused by a capabilty permission violation.  Other bits in the page
fault error code such as \texttt{P}, \texttt{W/R}, \texttt{U/S}, and
\texttt{I/D} should be set to indicate the type of memory access.  In
addition, the virtual address of the memory access should be provided
in the \CRTWO{} register similar to other page-fault exceptions.

Note that the \texttt{CR} and \texttt{CW} bits only fault if the
capability being read or written is tagged.  Untagged capability
values can be read from or written to memory regardless of the
\texttt{CR} and \texttt{CW} permissions.  In addition, if the
authorizing capability for a capability read does not hold \cappermLC,
then reading a tagged capability will always return a capability with
the tag cleared instead of faulting.

Instruction fetches always ignore tags and will never raise a
capability page-fault exception.
