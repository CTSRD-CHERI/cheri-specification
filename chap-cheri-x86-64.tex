\chapter{The CHERI-x86-64 Instruction-Set Architecture (Sketch)}
\label{chap:cheri-x86-64}

\rwnote{New introduction is required, and some change of pitch.}

In this chapter, we explore models for applying CHERI protection to the x86
architecture.
The x86 architecture is a widely deployed CPU architecture used in a
variety of applications ranging from mobile to high-performance computing.
The architecture has evolved over time from 16-bit processors without
MMUs to present-day systems with 64-bit processors supporting virtual
memory via a combination of segmentation and paging.

The x86 architecture has spanned three register sizes (16, 32, and
64 bits) and multiple memory management models.  We choose to define
CHERI solely for the 64-bit x86 architecture for a variety of reasons
including its more mature virtual-memory model, as well as its larger
general-purpose integer register file.

\section{Capability Registers versus Segments}

The x86 architecture first added virtual memory support via
relocatable and variable-sized segments.  Each segment was assigned a
mask of permissions.  Memory references were resolved with respect to a
specific segment including relocation to a base address, bounds
checking, and access checks.  Special segment types permitted transitions
to and from different protection domains.

These features are similar to features in CHERI capabilities.
However, there are also some key differences.

First, x86 addresses are stored as a combination of an offset and a
segment spanning two different registers.  General-purpose registers
are used to hold offsets, and dedicated segment selector registers are
used to hold information about a single segment.  The x86 architecture
provides six segment selector registers -- three of which are reserved
for code, stack, and general data accesses.  A fourth register is
typically used to define the location of thread-local storage (TLS).
This leaves two segment registers to use for fine-grained segments
such as separate segments for individual stack variables.  These
registers do not load a segment descriptor from arbitrary locations in
memory.  Instead, each register selects a segment descriptor from a
descriptor table with a limited number of entries.  One could treat
the segment descriptor tables (or portions of these tables) as a cache
of active segments.

Second, more fine-grained segments are not derived from existing
segments.  Instead, each entry in a descriptor table is independent.
Write access to a descriptor table permits construction of arbitrary
segments (including special segments that permit privilege
transitions).  Restricting descriptor-table write access to kernel
mode does not protect against construction of arbitrary segments in
kernel mode due to bugs or vulnerabilities.  As a result, segment
descriptors are not able to provide the same provenance guarantees as
tagged capabilities.

Third, existing segment descriptors do not have available bits for
storing types or permissions more expressive than the existing
read, write, and execute.

Finally, x86 segmentation is typically not used in modern operating
systems.  On the 32-bit x86 architecture, systems generally create
segments with infinite bounds and use a non-zero base address only
for a single segment that provides TLS.  The 64-bit x86 architecture
codifies this by removing segment bounds entirely and supporting non-zero-base
addresses only for two segment registers.
Software for x86 systems stores only the offset portion of virtual
addresses in pointer variables.  Segment registers are set to fixed
values at program startup, never change, and are largely ignored.

One approach for providing a similar set of features to CHERI
capabilities on x86 would be to extend the existing segment primitives
to accommodate some of these differences.  For example, descriptor-table
entries could be tagged, whereby loading an untagged segment would trigger
an exception.  However, some other potential changes are broader in
scope (e.g., whether segment selectors should contain an index into a
table, versus a logical address of a segment descriptor).  Extending
segments would also result in a very different model compared to CHERI
capabilities on other architectures, limiting the ability to share code
and algorithms.  Instead, we propose to add CHERI capabilities to 64-bit
x86 by extending existing general-purpose integer registers.

\section{Tagged Capabilities and Memory}

As with CHERI-MIPS and CHERI-RISC-V, we recommend that both memory and
registers contain tagged capabilities.  Similar to CHERI-RISC-V, we also
recommend a single, 128-bit format for CHERI-x86-64 capabilities.

Since capabilities require 16 byte alignment in memory, attempts to
load or store capabilities at misaligned addresses should raise a
General Protection Fault with an error code of zero similar to
misaligned loads and stores of SSE registers.

\section{Extending Existing Registers}

The x86 architecture has expanded its general-purpose integer registers multiple
times.  Thus, the 16-bit \AX{} register has been extended to 32-bit \EAX{}
and 64-bit \RAX{}.
We propose extending each general-purpose integer register to a tagged, 128-bit register
able to contain a single capability.
The capability-sized registers would be named with a `C' prefix in place
of the `R' prefix used for 64-bit registers
(\CAX{}, \CBX{}, etc.).
As with CHERI-RISC-V,
we recommend that the bottom 64 bits of capability registers contain
the integer value (virtual address) and the upper 64 bits contain
capability metadata.
Reads of capability registers as integers return the integer value.
Integer writes to capability registers
should clear the tag and upper 64 bits of capability metadata, storing the
desired integer value in the bottom 64 bits.

The \RIP{} register (which contains the address of the current instruction)
would also be extended into a \CIP{} capability.  This would function as
the equivalent of \PCC{} for CHERI-MIPS and CHERI-RISC-V.  As with
those architectures, the
value of \RIP{} should be the current offset of \CIP{} rather than the
integer value (virtual address).

\section{Additional Capability Registers}
\label{sec:x86:additional-caps}

Additional capability registers beyond those present in the general-purpose
integer
register set will also be required.

A new register will be required to hold \DDC{} for controlling
non-capability-aware memory accesses.

The x86 architecture currently uses the \FS{} and \GS{} segment selector registers
to provide thread-local storage (TLS).  In the 64-bit x86 architecture,
these selectors are mostly reduced to holding an alternate base address
that is added as an offset to the virtual address of existing instructions.
For CHERI-x86-64 we recommend replacing these segment registers with two
new capability registers: \CFS{} and \CGS{}.

In addition, new capability control registers will be required to
manage user to kernel transitions as described in
Section~\ref{sec:x86:capability-control-registers}.

These additional registers would be stored as a second bank of
capability registers after the existing bank of general-purpose
registers.  Using these additional registers as instruction operands
will require extending the relevant register selector field to five
bits.

\section{Using Capabilities with Memory Address Operands}

As with other CHERI architectures, CHERI-x86-64 should support running existing
x86-64 code, capability-aware code, and hybrid code.  This
requires the architecture to support multiple addressing modes.
The x86 architecture has implemented this in the past when it was
extended to support 32-bit operation.  We propose to reuse some of the
same infrastructure to support a new capability-based addressing
mode.

When x86 was extended from 16 bits to 32 bits, the architecture
included the ability to run existing 16-bit code without modification
as well as execute individual 16-bit or 32-bit instructions within a
32-bit or 16-bit codebase.  The support for 16-bit versus 32-bit
operation was
split into two categories: operand size and addressing modes.  The
code segment descriptor contains a single-bit `D' flag, which sets the
default operand size and addressing mode.  These attributes can then
be toggled to the non-default setting via opcode prefixes.  The 0x66
prefix is used to toggle the operand size, and the 0x67 prefix is used
to toggle the addressing mode.

In 64-bit (``long'') mode, the `D' flag is currently always set to
0 to indicate 32-bit operands and 64-bit addressing.  A value of
1 for `D' is reserved.  The 0x67 opcode prefix is used to toggle
between 32-bit and 64-bit addresses, but a few other single-byte opcodes
are invalid in 64-bit mode and could be repurposed as a prefix.

We propose a new capability-aware addressing mode that can be
toggled via the `D' flag of the current code segment and a new 0x07
opcode prefix.  (In 32-bit x86, the 0x07 opcode is the
\insnnoref{POP ES} instruction, which is invalid in 64-bit mode.)
If the `D' flag of a 64-bit code segment is set to 1,
then the CPU would execute in ``capability mode'' -- which would include
using the capability-aware addressing mode by default.  Individual
instructions could toggle between capability-aware and ``plain''
64-bit addressing via the 0x07 opcode prefix.  Addresses using the
``plain'' 32-bit or 64-bit addressing would always be treated as offsets
relative to \DDC{}.  Instructions using capability-aware addressing
would always use 64-bit virtual addresses and ignore any 0x67 opcode
prefix.

Note that one can change the value of \CS{} in user mode (for example,
a user process in FreeBSD/amd64 can switch between 32 and 64-bit by
using a far call that loads a different value of \CS{}).  This would mean
that user code could swap into pure-capability mode without requiring
a system call.  However, this would not alter the contents of
capability registers or their enforcement, merely the decoding of
instructions.  If \DDC{} is invalid, then sandboxed code that switched to
a non-capability \CS{} would still require valid capability registers to
access memory.

\subsection{Capability-Aware Addressing}

For instructions with register-based memory operands, capability-aware
addressing would use the capability version of the register rather
than the virtual address relative to \DDC{}.

For example:

\begin{verbatim}
mov 0x8(%cbp),%rax
\end{verbatim}

would read the 64-bit value at offset 8 from the capability described
by the \CBP{} register.

On the other hand,

\begin{verbatim}
mov 0x8(%rbp),%rax
\end{verbatim}

would read the 64-bit value at an offset of RBP+8 from the \DDC{} capability.
Both instructions would use the same opcode aside from the addition of
an 0x07 opcode prefix.  In a code segment with `D' set to 1, the second
instruction would require the prefix.  In a code segment with `D' set to 0,
the first instruction would require the prefix.

\subsection{Scaled-Index Base Addressing}

x86 also supports an addressing mode that combines the values of two
registers to construct a virtual address known as scaled-index base
addressing.  These addresses use one register, the \emph{base}, and a
second register, the \emph{index}, multiplied by a scaling factor of 1, 2,
4, or 8.  For these addresses, capability-aware addresses would select
a capability for the base register, but the index register would use
the integer value of the register.  For example:

\begin{verbatim}
mov (%rax,%rbx,4),%rcx
\end{verbatim}

This computes an effective address of \RAX{} + \RBX{} * 4 and loads the value
at that address into \RCX{},  The capability-aware version would be:

\begin{verbatim}
mov (%cax,%rbx,4),%rcx
\end{verbatim}

That is, starting with the \CAX{} capability, \RBX{} * 4 would be added to the
offset, and the resulting address validated against the \CAX{} capability.

\subsection{RIP-Relative Addressing}

The 64-bit x86 architecture added a new addressing mode to support more
efficient Position-Independent Code (PIC) performance.
This addressing mode uses an immediate offset
relative to the current value of the instruction
pointer.  These addresses are known as \RIP{}-relative addresses.

To support existing code, \RIP{}-relative addresses should be resolved
relative to \DDC{} when using ``plain'' 64-bit addressing.
Specifically, the value of \RIP{} (offset of \CIP{}) would be added to
the immediate offset.  The resulting value would then be used as an
offset relative to \DDC{} for the load or store.

When capability-aware addressing is used, \RIP{}-relative addresses
should be resolved relative to \CIP{}.
The immediate offset is applied to \CIP{} and the load
or store is constrained by the bounds and permissions of \CIP{}.

\subsection{Using Additional Capability Registers as a Base Address}
\label{sec:x86:additional-caps-as-base}

The proposed capability-aware addressing mode proposed above allows
for the capability versions of existing general-purpose integer registers such
as \CAX{} or \CBP{} to be encoded as the base address in existing register instructions.
However, it does not permit the direct use of the additional
capability registers \DDC{}, \CFS{}, or \CGS{}.  \DDC{} is not expected to be
used as an explicit base address, but \CFS{} and \CGS{} must be usable in this
manner to support TLS with capability-aware addresses.

One option would be to repurpose the existing \FS{} and \GS{} segment
prefixes when used with instructions using capability-aware addresses
to select an implicit base register of \CFS{} or \CGS{}, respectively.
However, this approach is potentially confusing.  Would an instruction
using an existing address of ``(\%cax)'' and an instruction prefix of
``GS:'' simply use the integer value of \CAX{} (value of \RAX{}) as an offset
relative to \CGS{}?

To avoid this confusion, we propose to reuse the existing \GS{}
segment prefix to extend the capability register selector field for
the base address register in memory operands.  When this prefix is
present, a capability register with an index of 16 or higher would be
used as the base address.  The lower four bits of the register
selector would be determined by the existing registor selector fields.

\subsection{Instructions with Implicit Memory Operands}

Some x86 instructions have implicit memory operands addressed by a
register.  These instructions should support addressing memory with
capabilities.

The ``string''
instructions use \RSI{} as source address and \RDI{} as a destination address.
For example, the
\insnnoref{STOS} instruction stores the value in \AL{}/\AX{}/\EAX{}/\RAX{} to the address in
\RDI{}, and then either increments or decrements the destination
index register (depending on the Direction Flag).  When capability
addressing mode is enabled,
these string instructions should use \CSI{} instead of \RSI{} and \CDI{} instead of
\RDI{}.

\insnnoref{XLAT} should use \CBX{} as the implicit table address when
using capability-aware addressing.

\subsection{Stack Address Size}

Instructions that work with the stack such as \insnnoref{PUSH} or
\insnnoref{CALL} use the stack pointer as an implicit operand.  In
32-bit x86, the `B' flag of the stack segment selector determines if
the 16-bit or 32-bit stack pointer register is used.  In 64-bit long
mode, \RSP{} is always used as the stack pointer.

To support a CHERI stack pointer, we propose reusing the `B' flag of
the stack segment selector to determine the stack pointer.  When `B'
is clear, \RSP{} would be treated as an offset into \DDC{} to compute
the stack pointer.  When `B' is set, \CSP{} would be used as the stack
pointer.  Code which needs to use the alternate stack pointer
interpretation would simulate these instructions using \insnnoref{MOV}
instructions and adjusting the desired stack pointer using
instructions such as \insnnoref{ADD} or \insnnoref{SUB}.  Emulation of
\insnnoref{CALL} or \insnnoref{RET} would use \insnnoref{JMP} to
adjust the instruction pointer.

\section{Capability-Aware Instructions}

CHERI-x86-64 will require new instructions to examine and modify
capabilities.  Many of these new instructions can be implemented as
new variants of existing instructions that use an opcode which
specifies a capability operation rather than an integer operation.
Existing x86 toolchains already use instruction suffixes such as
\texttt{b}, \texttt{w}, \texttt{l}, and \texttt{q} to explicitly state
the operand size.  We recommand that the \texttt{c} suffix be used to
explicitly state a capability operand size.

We consider three different strategies for supporting capability
operands.

\subsection{Capability Operands via Operand Size Prefix}

Previous extensions to the x86 architecture have relied on opcode
prefixes combined with the `D' and `L' flags of the current code
segment to determine the operand size.  The first strategy we
will consider uses a similar
scheme for supporting capability-sized operands.

First, we propose reusing a single-byte opcode declared invalid in
64-bit mode such as 0x06 (\insnnoref{PUSH ES}) as an opcode prefix
(\textbf{capability operand prefix}).

When not executing in ``capability mode'', existing instructions will
follow the existing rules for 64-bit ``long mode'' as defined by the
0x66 prefix and \texttt{REX.W} flag to set the operand size.  If an
instruction supports capability-sized operands, the capability operand
prefix can be used to use a capability-sized operand instead.  This
prefix would have higher precedence than both both \texttt{REX.W} and
the 0x66 prefix.

In ``capability mode'', most instructions which can operate on either
integer or capability-sized values would follow the same logic in the
previous paragraph to determine the operand size.  However, a few
instructions would default to using a capability-sized operand when
executed in ``capability mode''.  For these instructions, the
capability operand prefix could be used to revert to a smaller operand
size.  The effective operand size would then determined by \texttt{REX.W}
and the 0x66 prefix.

One important consideration for instructions in this strategy is how
to extend register selector fields to five bits.  Similar to the
approach described for base address registers in
Section~\ref{sec:x86:additional-caps-as-base}, other segment prefixes
such as \FS{} or \ES{} could be used to imply a fifth bit of 1 for
other register operands.

\subsection{Capability Operands via VEX Prefixes}

The second strategy would avoid reusing existing opcodes for
instructions with capability operands.  Instead, new opcodes would be
allocated for each instruction which accepts capability operands.  For
these new instructions, the upper three bits of the \texttt{VEX.mmmmm}
field would be used as the 5th bit of the register selector fields
similar to \texttt{EVEX.R'}, \texttt{EVEX.X}, and \texttt{EVEX.V'}
fields in \EVEX{} prefixes.  If an instruction only operates on
capability registers in the general-purpose register set, then a two
byte \VEX{} prefix could be used.

\subsection{Capability Operands via Both Methods}

Each of the two strategies given above have tradeoffs.  Using opcode
prefixes can result in shorter opcodes.  On the other hand, the use of
multiple segment prefixes to expand register fields may prove
unwieldy.  The use of \VEX{} prefixes would permit new CHERI-specific
instructions to accept three operands instead of two.

A third strategy would combine these two approaches.  Some existing
instructions would use the first approach.  These instructions would
only be able to use the first 16 general-purpose registers as operands
(with the exception of the base memory address register for any memory
operands) to avoid the requirement for multiple segment prefixes on a
single instruction.  This would permit the reuse of existing shorter
opcodes for frequently used instructions such as \insnnoref{CALL} and
\insnnoref{RET}.

Other instructions (including new CHERI-specific instructions) would
use new two- or three-byte opcodes compatible with \VEX{} prefixes.

The following sections describe specific instructions in more detail
assuming this third strategy.

\subsection{Control-Flow Instructions}

Relative control-flow instructions such as \insnnoref{JMP},
\insnnoref{CALL}, and conditional jumps (\insnnoref{Jcc}) would modify
the offset of the \CIP{} capability.  If the resulting value of \CIP{}
is invalid, a capability violation fault would be raised when fetching
the next instruction (see Section~\ref{sec:x86:capability-fault}).

All other control-flow instructions would support capability operands
via the capability operand prefix and would default to capability
operands in ``capability mode''

Absolute near calls and jumps which used an integer operand
would set the offset of the \CIP{} capability while instructions
using a capability operand would load a new capability into \CIP{}.

For far calls and jumps with a capability-sized operand,
the memory address would point
to a 16-bit segment selector followed by a capability.  Note that the

low four bits of the memory address would have to be set to 14 to
align the capability.  The current segment selector would be pushed
onto the stack as a 16-byte value where the first two bytes contain
the selector and the remaining 14 bytes' value is undefined.  Far
calls and jumps with an integer operand would use the integer operand
to set the offset of \CIP{}.  Note that while a far call or jump with
an integer operand doesn't seem very useful in ``capability mode'', a
far call or jump with a capability operand in plain 64-bit mode may be
desirable as a way to enter ``capability mode''.

A near \insnnoref{RETC} would pop a capability off of the stack and
load it into \CIP{}.  A far \insnnoref{RETC} would additionally pop
a 16-byte value off of the stack of which the low 16 bits are used
as the new code segment selector.  The integer versions of
\insnnoref{RET} would use the integer value popped off of the stack
as the new offset of \CIP{}.

\insnnoref{IRETC} should pop a capability exception frame (see
Section~\ref{sec:x86:interrupt-exception}) from the stack loading
capabilities into \CIP{} and \CSP{}.

Note that attempting to push or pop a misaligned capability will raise
an exception.  The stack pointer must be suitably aligned before the
use of \insnnoref{CALLC}, \insnnoref{IRETC}, and \insnnoref{RETC}.

\subsection{Extending Existing Instructions to Support Capability Operands}

Several existing instructions should be extended to support
capability operands:

\begin{itemize}
  \item \insnnoref{MOVC} would handle loads and stores of
    capabilities similar to \insnref{CLC} and \insnref{CSC} as well as
    copying capabilities between registers similar to \insnref{CMove}.

    The existing \texttt{89} and \texttt{8B} opcodes would be extended
    to support capability operands via the capability operand prefix.
    Note that these instructions would only permit a general-purpose
    register as the source (\texttt{89}) or destination (\texttt{8B}).

    The \texttt{A1} and \texttt{A2} opcodes would be extended to use
    \CAX{} as the implicit operand when used with the capability
    operand prefix.

    To handle loads and stores as well as copying capabilities where
    at least one operand is an additional capability register, two
    new opcodes (such as \texttt{0F 24} and \texttt{0F 25}) would be
    used with a \VEX{} prefix.

    To support efficiently NULL pointers to memory, the \texttt{C7 /0}
    opcode would be extended to support capability operands via
    the capability operand prefix.  When extended to a capability
    operand, this instruction should store a NULL-derived capability
    using the immediate operand sign-extended to 64 bits as the
    integer value of the resulting capability.

    \insnnoref{MOV} should default to integer operands in ``capability
    mode''.

  \item \insnnoref{MOVNTIC} would store a single capability to memory
    using a non-temporal hint.

    The existing \texttt{0F C3} opcode would be extended to support
    capability operands via the capability operand prefix.  Note that
    this would only support stores of general-purpose capability
    registers.

    \insnnoref{MOVNTI} should default to integer operands in
    ``capability mode''.

  \item \insnnoref{CMOVC} would handle conditional loads and stores of
    capabilities.  Existing opcodes for \insnnoref{CMOV} would be
    extended to support capability operands via the capability operand
    prefix.  Note that this would only support moves to and from
    general-purpose capability registers.

    \insnnoref{CMOV} should default to integer operands in
    ``capability mode''.

  \item \insnnoref{ADDC} and \insnnoref{SUBC} would be used to adjust
    the offset of a capability similar to \insnref{CIncOffset}.  Note
    that for these instructions, the source operand would either be a
    sign-extended immediate or a 64-bit integer register whose value
    is either added to or subtracted from the offset of the
    capability-sized destination operand.

    For example:
 
\begin{verbatim}
add %csp,$16
\end{verbatim}

    would move the capability stack pointer up by 16 bytes.

    These instructions should set flag bits in \RFLAGS{} according to
    the integer value of the resulting capability.

    The \insnref{ADD} opcodes \texttt{01}, \texttt{03}, \texttt{05},
    \texttt{81 /0}, and \texttt{83 /0} and the \insnnoref{SUB}
    opcodes \texttt{29}, \texttt{2B}, \texttt{2D}, \texttt{81 /5} and
    \texttt{83 /5} would be extended to support capability operands
    via the capability operand prefix.

    \insnnoref{ADD} and \insnnoref{SUB} should default to integer
    operands in ``capability mode''.

    We do not anticipiate a need for capability-sized variants of
    \insnnoref{ADC} or \insnnoref{SBB}.

  \item \insnnoref{ANDC}, \insnnoref{ORC}, and \insnnoref{XORC} would
    permit bit manipulation of the integer value of a capability.  As
    with \insnnoref{ADDC}, the second operand would always be an
    integer operand.

    These instructions should set flag bits in \RFLAGS{} according to
    the integer value of the resulting capability.

    The \insnnoref{AND} opcodes \texttt{21}, \texttt{23}, \texttt{25},
    \texttt{81 /4} and \texttt{83 /4}; the \insnnoref{OR} opcodes
    \texttt{09}, \texttt{0B}, \texttt{0D}, \texttt{81 /1}, and
    \texttt{81 /3}; and the \insnnoref{XOR} opcodes \texttt{31},
    \texttt{33}, \texttt{35}, \texttt{81 /6}, and \texttt{83 /6} would
    be extended to support capability operands via the capability
    operand prefix.

    \insnnoref{AND}, \insnnoref{ORC}, and \insnnoref{XOR} should
    default to integer operands in ``capability mode''.

  \item \insnnoref{CMPXCHGC} will be required to support atomic
    operations on capabilities.  (Note that \insnnoref{CMPXCHG16B}'s
    existing semantics are not suitable for capabilities as it divides
    the values into register pairs.)

    The opcodes \texttt{0F B0} and \texttt{0F B1} would be extended to
    support capability operands via the capability operand prefix.

    \insnnoref{CMPXCHG} should default to integer operands in
    ``capability mode''.

  \item It may also be desirable to support \insnnoref{XADDC}.  For
    this instruction, only the integer portion of the second (source)
    operand would be added to the integer value of the first
    (destination) operand to determine the value stored to the
    destination.  Any tag or capability metadata in the second operand
    would be ignored and would be overwritten with the original value
    of the first operand.

    The opcode \texttt{0F C0} would be extended to support capability
    operands via the capability operand prefix.

    \insnnoref{XADDC} should set flag bits in \RFLAGS{} according to
    the integer value of the resulting capability.

    \insnnoref{XADD} should default to integer operands in
    ``capability mode''.

  \item \insnnoref{PUSHC} and \insnnoref{POPC} would be used to save
    and restore capability registers on the stack.

    In general, \insnnoref{PUSH} and \insnnoref{PUSHF} in ``capability
    mode'' would always push a 16 byte value onto the stack.  If the
    operand is not a capability register, then the sign-extended value
    of the operand is used as the address of NULL-derived capability
    which is pushed on the stack.  Similarly, \insnnoref{POP} and
    \insnnoref{POPF} would always pop a 16 byte value off of the
    stack.

    To save or restore a capability register in plain 64-bit mode, one
    would use \insnnoref{MOVC} to load or store the capability and
    adjust the stack pointer manually.

    In ``capability mode'' the use of the 0x66 prefix with
    \insnnoref{PUSH} or \insnnoref{POP} instructions would be
    reserved.

  \item \insnnoref{LEAC} would store the resulting address in a
    destination capability register.  If the instruction is using ``plain''
    addressing, the resulting capability would be a NULL-derived
    capability with the computed address.

    The opcode \texttt{8D} would be extended to support capability
    operands via the capability operand prefix.

    \insnnoref{LEA} should default to capability operands in
    ``capability mode''.

    \insnnoref{LEA}'s default disposition in ``capability mode''
    warrants further investigation.  If common use cases of this
    instruction are to perform arithmetic operations on integer values
    rather than computing addresses, it may make sense for
    \insnnoref{LEA} to use integer operands and ``plain'' addressing
    by default even in ``capability mode''.

  \item \insnnoref{ENTER} and \insnnoref{LEAVE} could be extended to
    support implicit capability operands, or they could be deprecated
    for capabilities and remain as integer-only instructions.

    If these instructions were extended to support capability
    operands, the capability-sized versions would operate on \CSP{}
    and \CBP{} rather than \RSP{} and \RBP{}.  These instructions
    would also default to capability operands in ``capability mode''
    if extended.
\end{itemize}

\subsection{New CHERI Instructions}

For other capability operations we
propose adding new CHERI-specific instructions.
Existing general-purpose x86 instructions support two operands rather
than three operands.  To avoid requiring a \VEX{} prefix for all new
CHERI instructions, most instructions are defined with two operands
rather than three.  New instructions which require three operands must
be encoded using a \VEX{} prefix.  In addition, instructions using a
capability from the upper bank, such as \DDC{}, \CFS{}, or \CGS{} as
one of the operands must use a three-byte \VEX{} prefix.

Operands are described using the syntax from Volume 2 of Intel's
Software Developer's Manual~\cite{intel-sdm-vol2} with the following
extensions:

\begin{itemize}
  \item \textbf{rc} { }---{ } One of the capability general-purpose
    registers: \CAX{}, \CBX{}, \CCX{}, \CDX{}, \CDI{}, \CSI{}, \CBP{},
    \CSP{}, \creg{8}-\creg{15}, \DDC{}, \CFS{}, \CGS{}; or one of
    capability control registers: \KCC{}, \KSC{}, \CSTAR{}, or \KGS{}.

  \item \textbf{r/mc} { }---{ } A capability operand that is either
    the contents of one of the capability registers for \textbf{rc} or
    a capability in memory.

   \item \textbf{uimm16} { }---{ } An unsigned immediate value.  This
     is a number between 0 and 65,535 inclusive.
\end{itemize}

\subsubsection{Capability-Inspection Instructions}

These instructions would set the \texttt{PF}, \texttt{SF}, and
\texttt{ZF} flags in \RFLAGS{} according to the integer field
extracted from the capability.

\begin{itemize}
  \item \insnref{CGetPerm} r64, r/mc
  \item \insnref{CGetType} r64, r/mc
  \item \insnref{CGetBase} r64, r/mc
  \item \insnref{CGetLen} r64, r/mc
  \item \insnref{CGetTag} r64, r/mc
  \item \insnref{CGetSealed} r64, r/mc
  \item \insnref{CGetOffset} r64, r/mc
  \item \insnref{CGetFlags} r64, r/mc
  \item \insnref{CGetSealed} r64, r/mc
  \item \insnref{CGetAddr} r64, r/mc
\end{itemize}

\subsubsection{Capability-Modification Instructions}

If these instructions fail, they should clear the tag in the resulting
capability rather than raising an exception as is done for CHERI-MIPS
and CHERI-RISC-V.  In addition, it is likely beneficial if these
instructions set \texttt{ZF} in \RFLAGS{} to the value of the tag of
the resulting capability to permit \texttt{ZF} to be used to determine
if these operations failed or succeeded (for example,
\insnref{CBuildCap}).

\begin{itemize}
  \item \insnref{CSeal} r/mc, rc
  \item \insnref{CUnSeal} r/mc, rc
  \item \insnref{CAndPerm} r/mc, r64
  \item \insnref{CSetFlags} r/mc, r64
  \item \insnref{CSetOffset} r/mc, r64
  \item \insnref{CSetAddr} r/mc, r64
  \item \insnref{CSetBounds} r/mc, r64
  \item \insnref{CSetBounds} r/mc, uimm16
  \item \insnref{CSetBoundsExact} r/mc, r64
  \item \insnref{CClearTag} r/mc
  \item \insnref{CBuildCap} rc, r/mc, rc

    This instruction uses three operands so that the two source operands
    can remain unchanged when using \insnref{CBuildCap} over a list of
    possible root capabilities.

  \item \insnref{CCopyType} r/mc, rc

    This instruction may warrant three operands for the same reason as
    \insnref{CBuildCap}.

  \item \insnref{CCSeal} rc, r/mc, rc
  \item \insnref{CSealEntry} r/mc
\end{itemize}

\subsubsection{Pointer-Arithmetic Instructions}

If these instructions fail, they should clear the tag in the resulting
capability rather than raising an exception as is done for CHERI-MIPS
and CHERI-RISC-V.  In addition, it is likely beneficial if these
instructions set \texttt{ZF} in \RFLAGS{} to the value of the tag of
the resulting capability.

\begin{itemize}
  \item \insnref{CToPtr} rc, r/mc
  \item \insnref{CFromPtr} r/mc, r64
\end{itemize}

\subsubsection{Pointer-Comparison Instructions}

For these instructions, the result of the comparison should be written
to the \texttt{ZF} field of \RFLAGS{} instead of to a destination
register as is done in CHERI-MIPS and CHERI-RISC-V.

\begin{itemize}
  \item \insnriscvref{CSetEqualExact} r/mc, rc
  \item \insnref{CTestSubset} r/mc, rc
\end{itemize}

Additionally, to support efficient tag checks without overwriting an
integer register with the result as is done in \insnref{CGetTag}, a
single operand \insnnoref{CTestTag} which copies the tag value to
\texttt{ZF} may be desired.

\subsubsection{Control-Flow Instructions}

\begin{itemize}
  \item \insnref{CInvoke} rc, r/mc
\end{itemize}

\subsubsection{Adjusting to Compresssed Capability Precision
  Instructions}

\begin{itemize}
  \item \insnref[CRoundRepresentableLength]{CRRL} r64, r/m64
  \item \insnref[CRepresentableAlignmentMask]{CRAM} r64, r/m64
\end{itemize}

\subsubsection{Tag-Memory Access Instructions}

\begin{itemize}
  \item \insnref{CLoadTags} r64, m
  \item \insnref{CClearTags} m
\end{itemize}

\section{Capability Violation Faults}
\label{sec:x86:capability-fault}

For reporting capability violations, we propose reserving a new
exception vector.  This new exception would report an error code
pushed as part of the exception frame similar to GP\# and PF\# faults.
This error code would contain the capability exception code as
described in Section~\ref{sec:capability_exception_causes} to indicate
the specific violation.

CHERI-MIPS and CHERI-RISC-V include the name of the register which
triggers a capability violation.  It is not feasible to provide a
direct analog of this on x86.  Indirect jumps and calls may raise an
exception while loading a capability from memory that is not present
in any register at the start of the instruction.  However, unlike page
faults, capability violation faults are not generally restartable and
the register name's primary use is for debugging convenience rather than
correctness.  There are a few possible options for providing similar
information:

\begin{enumerate}
\item Provide a copy of the faulting capability via one of the
  currently-unused but reserved control registers, such as \CRFIVE{}
  or \CRTWELVE{} -- similar to the PF\# virtual address stored in
  \CRTWO{}.  This faulting capability would include the result of any
  offset adjustments from immediates or scaled indices.  If the result
  of offset adjustments made the capability unrepresentable, the
  faulting capability would be a null capability holding the computed
  virtual address.
\item Similar to the above, but ignore offset adjustments and only
  provide the base capability value.
\item Provide the virtual address from the faulting capability in
  \CRTWO{} similar to PF\#.  A debugger could examine the faulting
  instruction's operands to determine which capability triggered the fault.
\item Do nothing as the prior approaches may be too expensive to
  implement.
\end{enumerate}

Unlike CHERI-MIPS and CHERI-RISC-V, we recommend that CHERI-x86-64
only raise capability violation faults when a invalid memory access is
performed such as an out-of-bounds access or access via an untagged
capability.  Specifically, we recommend that instructions which modify
capabilities should not raise capability violation faults (for
example, when a capability becomes unrepresentable) but should instead
clear the tag of the resulting capability.  This permits compilers to
speculatively reorder these instructions without raising spurious
faults during execution.

\section{Call Gates}

We do not recommend extending call gates to support capabilities.
Supporting capabilities with call gates would likely require the
following changes:

\begin{itemize}
  \item Extending the global and local descriptor table format to
    support a new capability call gate which stored a full capability
    rather than a 64-bit offset.  This will be more invasive than the
    64-bit call gate which depends on the abillity to force a number
    of reserved bits in the fourth double word to zero as a sentinel
    type for the second half of a 64-bit call gate.

    As with 64-bit call gates, capability call gates would not support
    parameter copying.

    Calls to a capability call gate would push a suitable ``far''
    return frame with each stack push made in a 16-byte increment.

  \item 64-bit call gates as well as capability call gates would need
    to support code segments with both the `L` and `D` bits set.

  \item A means would need to be set for determing the value of the
    `B' flag in the resulting stack segment.  For example, it could be
    copied from the `D' flag of the target code segment.
\end{itemize}

\section{Interrupt and Exception Handling}
\label{sec:x86:interrupt-exception}

For interrupt and exception handling, we propose a new overall CPU
mode that enables the use of capabilities.  The availability of this
mode would be indicated by a new \insnnoref{CPUID} flag.  The mode
would be enabled by setting a new bit in \CRFOUR{}.  When this mode is
enabled, exceptions would push a new type of interrupt frame.  As with
exceptions in long mode, the stack pointer would be 16-byte aligned
prior to pushing the exception frame to ensure capabilities are
aligned.  The \RIP{} and \RSP{} fields in the exception frame would be
replaced with the full \CIP{} and \CSP{} capabilities.  Other fields
in this frame would be padded to 16 bytes.  To minimize padding, it
may be desirable to pack multiple smaller registers into a single
16-byte slot; for example, \SS{}, \CS{}, and \RFLAGS{} could be stored
in a single slot.  However, this would result in a frame layout
inconsistent with far calls.  \insnnoref{IRETC} would be used in
interrupt service routines to unwind this frame.

\subsection{Capability Control Registers}
\label{sec:x86:capability-control-registers}

Interrupt and exception handlers require new capabilities for the
program counter (\CIP{}) and stack pointer (\CSP{}) registers.  These
values must be derived from valid, privileged capabilities.  To
support this, we propose the addition of a new class of capability
registers: capability control registers.

Capability control registers are capability-sized control registers.
As with other control registers such as \CRFOUR, direct access to
capability control registers would be restricted to supervisor mode as
well as requiring \cappermASR{} in \CIP{}.  Unlike other control
registers, however, capability control registers would not be accessed
via the \texttt{0F 20} and \texttt{0F 22} opcodes of \insnnoref{MOV}.
Instead, capability control registers would be named as additional
capability registers as described in
Section~\ref{sec:x86:additional-caps}.

We consider two possible approaches for deriving \CIP{} and \CSP{} at
the start of an interrupt or exception.

\subsubsection{Kernel Code and Stack Capabilities}

The first approach would add two new capability control registers: the Kernel
Code Capability (\KCC{}) and Kernel Stack Capability (\KSC{}).  Transitions into
supervisor mode would load new offsets relative to \KCC{} and \KSC{} from
existing data structures and tables to construct the new \CIP{} and \CSP{}
register values.  For example, the current virtual address stored in
each Interrupt Descriptor Table (\IDT{}) entry would be used as an offset
relative to \KCC{} to build \CIP{}, and the address stored in the Interrupt
Stack Table (\IST{}) entry in the current Task-State Segment (\TSS{}) would
be used as an offset relative to \KSC{} to build \CSP{}.  Transitions via
the \insnnoref{SYSCALL} instruction would use the offset from \LSTAR{} to
construct the new \CIP{}.

This approach does require broad capabilities
for \KCC{} and \KSC{} that can accommodate any desired entry point or stack
location.  However, it will require minimal changes to existing systems
code such as operating-system kernels.

\subsubsection{Capabilities in Entry Points}

The second approach would replace virtual addresses stored in
existing entry points with complete capabilities.  This is a more
invasive change, requiring larger changes to existing systems code, but
it enables the use of more fine-grained capabilities for each entry
point.

Setting the desired kernel stack pointers \CSP{} would require a new
\TSS{} layout that expanded the existing \RSP{} and \IST{} entries to
capabilities.

For \insnnoref{SYSCALL}, a new capability control register \CSTAR{} would be
added to hold the target instruction pointer.

Entries in the \IDT{} would be expanded to 32-bytes, appending a capability
code pointer in the last 16 bytes.  This would double the size of the
\IDT{}, and most of the bytes would be unused.  However, it would
ensure that all of the information currently stored in an \IDT{} entry
(such as the segment selector, \IST{} index, and descriptor type) would
be configurable.

\subsection{\insnnoref{SWAPGS} and Capabilities}

The \insnnoref{SWAPGS} instruction is used in user-to-kernel
transitions for the 64-bit x86 architecture to permit separate TLS
pointers for user and kernel mode.  One option would be to provide a
capability version of \insnnoref{SWAPGS}, either by extending the
\KGSBASE{} MSR to a capability, or adding a new MSR.  However, this
instruction can be difficult to use.  Interrupt and exception handlers
must be careful not to invoke \insnnoref{SWAPGS} if the interrupt
or exception is taken while executing the kernel mode \GS{}.  We
recommend avoiding the use of \insnnoref{SWAPGS}, and instead defining
a new capability control register \KGS{}.  Operating systems could
either choose to use \KGS{} to initialize \CGS{} in interrupt and
exception handlers, or else use \KGS{} directly as the kernel mode TLS
pointer.

\section{Page Tables}

Similar to CHERI on other architectures, additional page-table
permission bits governing loads and stores of capabilities are
desirable.  In addition, it may be beneficial to have a ``capability
dirty'' bit.  At present the 64-bit x86 architecture has reserved bits
in a range from bit 52 (\texttt{MAXPHYADDR}) to bit 62.  The Protection Keys
extension uses bits 59-62 from that range.  To avoid conflicting with
Protection Keys, CHERI-x86-64 could use bits starting at bit 58 as described in Table~\ref{table:x86:pte}.  Higher bits are
preferred, to permit maximal room for growth of the physical address
field that currently ends at bit 51.

\begin{table}
\begin{center}
\begin{tabular}{lll}
\toprule
Bit & Name & Description \\
\midrule
58 & CW & Permits writes of tagged capabilities \\
57 & CR & Permits reads of tagged capabilities \\
56 & CD & Set when a tagged capability is written to this page \\
\bottomrule
\end{tabular}
\end{center}
\caption{CHERI-x86-64 Page Table Bits}
\label{table:x86:pte}
\end{table}

If an instruction performs a memory access which violates a CHERI page
permission (such as a store of a tagged capability to a page where the
\texttt{CW} bit is clear), a page-fault (PF\#) exception should be
raised.  Bit 8 (currently reserved) should be set in the page-fault
error code provided by the processor indicating that the fault was
caused by a capabilty permission violation.  Other bits in the page
fault error code such as \texttt{P}, \texttt{W/R}, \texttt{U/S}, and
\texttt{I/D} should be set to indicate the type of memory access.  In
addition, the virtual address of the memory access should be provided
in the \CRTWO{} register similar to other page-fault exceptions.

Note that the \texttt{CR} and \texttt{CW} bits only fault if the
capability being read or written is tagged.  Untagged capability
values can be read from or written to memory regardless of the
\texttt{CR} and \texttt{CW} permissions.  In addition, if the
authorizing capability for a capability read does not hold \cappermLC,
then reading a tagged capability will always return a capability with
the tag cleared instead of faulting.

Instruction fetches always ignore tags and will never raise a
capability page-fault exception.

\section{Controlling Access to System Registers}

In CHERI-x86-64, \cappermASR{} would be required to directly access the
following registers:

\begin{itemize}
  \item Control registers including \KCC{}, \KSC{}, \CSTAR{}, and \KGS{}
  \item Debug registers
  \item Model-specific registers
\end{itemize}
